{
  "version": 3,
  "sources": ["../../../src/build-docker-image/index.js"],
  "sourcesContent": ["const core = require('@actions/core');\r\nconst exec = require('@actions/exec');\r\nconst github = require('@actions/github');\r\nconst fs = require('node:fs/promises');\r\nconst path = require('node:path');\r\nconst os = require('node:os'); // Import the 'os' module\r\n\r\nasync function run () {\r\n  try {\r\n    // Get inputs\r\n    const dockerfile = core.getInput('Dockerfile', { required: true });\r\n    let dockerBuildArgs = core.getInput('DockerBuildArgs'); // Defaults to \"\" if not provided.\r\n    const repository = core.getInput('Repository', { required: true });\r\n\r\n    const context = dockerfile.substring(0, dockerfile.lastIndexOf('/')) || '.'; // Extract directory of Dockerfile.\r\n    core.info(`Dockerfile context directory: ${context}`);\r\n\r\n    // Determine if we should use the cache.  Avoid cache if it's a PR from a fork.\r\n    const isPullRequest = github.context.eventName === 'pull_request';\r\n    const isFork = isPullRequest && github.context.payload.pull_request.head.repo.fork;\r\n    const useCache = !isFork;\r\n    const containerRegistry = 'onnxruntimebuildcache'; // Moved this here as it is a constant\r\n    const useContainerRegistry = useCache; // Simplified since they have the same condition\r\n\r\n    let azLoginRan = false;\r\n\r\n    if (useContainerRegistry) {\r\n      // Log in to Azure\r\n      try {\r\n        // Suppress stdout and stderr by redirecting to /dev/null (or equivalent)\r\n        // Added --output none\r\n        await exec.exec('az', ['login', '--identity', '--output', 'none'], { outStream: null, errStream: null });\r\n        azLoginRan = true;\r\n        await exec.exec('az', ['acr', 'login', '-n', containerRegistry]);\r\n      } catch (error) {\r\n        core.setFailed(`Azure login or ACR login failed: ${error.message}`);\r\n        return; // Exit if login fails.  Critical error.\r\n      }\r\n    }\r\n\r\n    const fullImageName = useContainerRegistry\r\n      ? `${containerRegistry}.azurecr.io/${repository}:latest`\r\n      : `${repository}:latest`;\r\n\r\n    core.info(`Image: ${fullImageName}`);\r\n    const repoDir = process.env.GITHUB_WORKSPACE;\r\n\r\n    // Copy deps.txt if it doesn't exist in the Dockerfile's context.\r\n    const dstDepsFile = path.join(context, 'scripts', 'deps.txt');\r\n    try {\r\n      await fs.access(dstDepsFile);\r\n      core.info('deps.txt already exists. No need to copy');\r\n    } catch {\r\n      core.info(`Copying deps.txt to: ${dstDepsFile}`);\r\n      await fs.mkdir(path.dirname(dstDepsFile), { recursive: true }); // Ensure 'scripts' directory exists\r\n      await fs.copyFile(path.join(repoDir, 'cmake', 'deps.txt'), dstDepsFile);\r\n    }\r\n    let dockerCommand = ['build'];\r\n    if (useContainerRegistry) {\r\n      dockerCommand = ['buildx', 'build', '--load'];\r\n      dockerCommand.push('--cache-from', `type=registry,ref=${fullImageName}`);\r\n      dockerCommand.push('--build-arg', 'BUILDKIT_INLINE_CACHE=1');\r\n    } else {\r\n      dockerCommand.push('--pull');\r\n    }\r\n\r\n    // Get the current user ID.\r\n    const uid = os.userInfo().uid;\r\n    core.info(`Current user ID: ${uid}`);\r\n    dockerBuildArgs += ` --build-arg BUILD_UID=${uid}`;\r\n\r\n    if (dockerBuildArgs) {\r\n      // Split the dockerBuildArgs string into an array, handling spaces and quotes correctly.\r\n      const argsArray = dockerBuildArgs.split(/\\s(?=(?:[^'\"`]*(['\"`])[^'\"`]*\\1)*[^'\"`]*$)/).filter(Boolean);\r\n      for (const arg of argsArray) {\r\n        dockerCommand.push(arg);\r\n      }\r\n    }\r\n\r\n    dockerCommand.push('--tag', fullImageName);\r\n    dockerCommand.push('--file', dockerfile);\r\n    dockerCommand.push(context);\r\n\r\n    // Execute the Docker build command.\r\n    try {\r\n      if (useContainerRegistry) {\r\n        await exec.exec('docker', ['--log-level', 'error', ...dockerCommand]);\r\n      } else {\r\n        await exec.exec('docker', dockerCommand);\r\n      }\r\n    } catch (error) {\r\n      core.setFailed(`Docker build failed: ${error.message}`);\r\n      return; // Exit if docker build failed.\r\n    }\r\n\r\n    // Tag the image with the repository name.\r\n    await exec.exec('docker', ['tag', fullImageName, repository]);\r\n\r\n    // Push only if using the container registry AND it's a push to the main branch.\r\n    if (useContainerRegistry && github.context.ref === 'refs/heads/main' && github.context.eventName === 'push') {\r\n      await exec.exec('docker', ['push', fullImageName]);\r\n    } else {\r\n      if (github.context.ref !== 'refs/heads/main' || github.context.eventName !== 'push') {\r\n        core.info('Skipping docker push. Not a push to the main branch.');\r\n      }\r\n    }\r\n    // Logout from Azure ACR (if we logged in) using docker logout\r\n    if (azLoginRan) {\r\n      const registryUrl = `${containerRegistry}.azurecr.io`;\r\n      try {\r\n        await exec.exec('docker', ['logout', registryUrl]);\r\n      } catch (error) {\r\n        core.warning(`Docker logout failed: ${error.message}`); // Warning, not critical.\r\n      }\r\n    }\r\n\r\n    core.info('Docker build completed successfully.');\r\n  } catch (error) {\r\n    core.setFailed(error.message);\r\n  }\r\n}\r\n\r\nrun();\r\n"],
  "mappings": "AAAA,IAAMA,EAAO,QAAQ,eAAe,EAC9BC,EAAO,QAAQ,eAAe,EAC9BC,EAAS,QAAQ,iBAAiB,EAClCC,EAAK,QAAQ,kBAAkB,EAC/BC,EAAO,QAAQ,WAAW,EAC1BC,EAAK,QAAQ,SAAS,EAE5B,eAAeC,GAAO,CACpB,GAAI,CAEF,IAAMC,EAAaP,EAAK,SAAS,aAAc,CAAE,SAAU,EAAK,CAAC,EAC7DQ,EAAkBR,EAAK,SAAS,iBAAiB,EAC/CS,EAAaT,EAAK,SAAS,aAAc,CAAE,SAAU,EAAK,CAAC,EAE3DU,EAAUH,EAAW,UAAU,EAAGA,EAAW,YAAY,GAAG,CAAC,GAAK,IACxEP,EAAK,KAAK,iCAAiCU,CAAO,EAAE,EAKpD,IAAMC,EAAW,EAFKT,EAAO,QAAQ,YAAc,gBACnBA,EAAO,QAAQ,QAAQ,aAAa,KAAK,KAAK,MAExEU,EAAoB,wBACpBC,EAAuBF,EAEzBG,EAAa,GAEjB,GAAID,EAEF,GAAI,CAGF,MAAMZ,EAAK,KAAK,KAAM,CAAC,QAAS,aAAc,WAAY,MAAM,EAAG,CAAE,UAAW,KAAM,UAAW,IAAK,CAAC,EACvGa,EAAa,GACb,MAAMb,EAAK,KAAK,KAAM,CAAC,MAAO,QAAS,KAAMW,CAAiB,CAAC,CACjE,OAASG,EAAO,CACdf,EAAK,UAAU,oCAAoCe,EAAM,OAAO,EAAE,EAClE,MACF,CAGF,IAAMC,EAAgBH,EAClB,GAAGD,CAAiB,eAAeH,CAAU,UAC7C,GAAGA,CAAU,UAEjBT,EAAK,KAAK,UAAUgB,CAAa,EAAE,EACnC,IAAMC,EAAU,QAAQ,IAAI,iBAGtBC,EAAcd,EAAK,KAAKM,EAAS,UAAW,UAAU,EAC5D,GAAI,CACF,MAAMP,EAAG,OAAOe,CAAW,EAC3BlB,EAAK,KAAK,0CAA0C,CACtD,MAAQ,CACNA,EAAK,KAAK,wBAAwBkB,CAAW,EAAE,EAC/C,MAAMf,EAAG,MAAMC,EAAK,QAAQc,CAAW,EAAG,CAAE,UAAW,EAAK,CAAC,EAC7D,MAAMf,EAAG,SAASC,EAAK,KAAKa,EAAS,QAAS,UAAU,EAAGC,CAAW,CACxE,CACA,IAAIC,EAAgB,CAAC,OAAO,EACxBN,GACFM,EAAgB,CAAC,SAAU,QAAS,QAAQ,EAC5CA,EAAc,KAAK,eAAgB,qBAAqBH,CAAa,EAAE,EACvEG,EAAc,KAAK,cAAe,yBAAyB,GAE3DA,EAAc,KAAK,QAAQ,EAI7B,IAAMC,EAAMf,EAAG,SAAS,EAAE,IAI1B,GAHAL,EAAK,KAAK,oBAAoBoB,CAAG,EAAE,EACnCZ,GAAmB,0BAA0BY,CAAG,GAE5CZ,EAAiB,CAEnB,IAAMa,EAAYb,EAAgB,MAAM,4CAA4C,EAAE,OAAO,OAAO,EACpG,QAAWc,KAAOD,EAChBF,EAAc,KAAKG,CAAG,CAE1B,CAEAH,EAAc,KAAK,QAASH,CAAa,EACzCG,EAAc,KAAK,SAAUZ,CAAU,EACvCY,EAAc,KAAKT,CAAO,EAG1B,GAAI,CACEG,EACF,MAAMZ,EAAK,KAAK,SAAU,CAAC,cAAe,QAAS,GAAGkB,CAAa,CAAC,EAEpE,MAAMlB,EAAK,KAAK,SAAUkB,CAAa,CAE3C,OAASJ,EAAO,CACdf,EAAK,UAAU,wBAAwBe,EAAM,OAAO,EAAE,EACtD,MACF,CAcA,GAXA,MAAMd,EAAK,KAAK,SAAU,CAAC,MAAOe,EAAeP,CAAU,CAAC,EAGxDI,GAAwBX,EAAO,QAAQ,MAAQ,mBAAqBA,EAAO,QAAQ,YAAc,OACnG,MAAMD,EAAK,KAAK,SAAU,CAAC,OAAQe,CAAa,CAAC,GAE7Cd,EAAO,QAAQ,MAAQ,mBAAqBA,EAAO,QAAQ,YAAc,SAC3EF,EAAK,KAAK,sDAAsD,EAIhEc,EAAY,CACd,IAAMS,EAAc,GAAGX,CAAiB,cACxC,GAAI,CACF,MAAMX,EAAK,KAAK,SAAU,CAAC,SAAUsB,CAAW,CAAC,CACnD,OAASR,EAAO,CACdf,EAAK,QAAQ,yBAAyBe,EAAM,OAAO,EAAE,CACvD,CACF,CAEAf,EAAK,KAAK,sCAAsC,CAClD,OAASe,EAAO,CACdf,EAAK,UAAUe,EAAM,OAAO,CAC9B,CACF,CAEAT,EAAI",
  "names": ["core", "exec", "github", "fs", "path", "os", "run", "dockerfile", "dockerBuildArgs", "repository", "context", "useCache", "containerRegistry", "useContainerRegistry", "azLoginRan", "error", "fullImageName", "repoDir", "dstDepsFile", "dockerCommand", "uid", "argsArray", "arg", "registryUrl"]
}
